## @package Eurystheus
#  Documentation for this module.
#
#  More details.
import random
import math
import sys
import hashlib
from deap import creator, base, tools, algorithms

class EvStOptimizer:

    def __init__(self,fitness,options={}):
        #GA parameters
        self.numGen = int(options['numgen'])
        self.mutProb= float(options['mut_prob'])
        self.crossProb=float(options['cross_prob'])
        self.numSel=int(options['num_sel'])
        self.muSel=int(options['mu_sel'])
        self.lambdaSel=int(options['lambda_sel'])
        self.innerMutProb=float(options['inner_mut_prob'])
        self.populationSize=int(options['population_size'])
        self.tournamentSel=int(options['tournament_sel'])
        #Individual Initialization parameters
        self.tsize = int(options['sizetuples'])
        self.isize = int(options['numtuples'])
        self.types = list(options["type"+str(i)] for i in range(self.tsize))
        self.minInt = int(options['minInt'])
        self.maxInt = int(options['maxInt'])
        self.minFloat= float(0)
        self.maxFloat= float(options['noise'])
        self.fitness=fitness
        self.weights=options["weights"]
        ## Documentation for randomInit
        # @param icls individual composed by tuples
        # @param low vector for minimum values for each element of a tuple
        # @param top vector for maximum values of the tuples
        # @param size individual size
        # @brief this function initializes an individual
    def randomInit(self,icls):
        #TODO: Arreglar random del float random
        ind = icls(random.random() if self.types[index%self.tsize]=='float' else random.randint(self.minInt,self.maxInt) for index in range(self.isize*self.tsize))
#        ind[0]=0
        return ind

    ## Documentation for randomInit
    # @param icls individual composed by tuples
    # @param low vector for minimum values for each element of a tuple
    # @param top vector for maximum values of the tuples
    # @param size individual size
    # @brief this function initializes an individual
    def mutUniform(self,individual):
        ind2=individual
        for index, elem in enumerate(individual):
            if random.random() < self.innerMutProb:
                #TODO:Rango para los float
                ind2[index] = random.random() if self.types[index%self.tsize]=='float' else random.randint(self.minInt,self.maxInt)
        return ind2,

    ## Documentation for evalFitness
    # @param individual individual composed by tuples
    # @brief this function fakes an individual fitness
    def evalFitness(self,individual):
        #inputs=[individual[x:x+self.tsize] for x in range(0,len(individual),self.tsize)]
        return self.fitness(individual)

#    def fitness(self,inputs):
#        return 1
    
    def optimize(self):
#        creator.create("FitnessMin", base.Fitness, weights=(-1.0,-1.0,-1.0))
        creator.create("FitnessMin", base.Fitness, weights=self.weights)
        creator.create("Individual", list, fitness=creator.FitnessMin)
        toolbox = base.Toolbox()
        toolbox.register("individual", self.randomInit, creator.Individual)
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
        toolbox.register("evaluate", self.evalFitness)
        toolbox.register("mate", tools.cxTwoPoint)
        toolbox.register("mutate", self.mutUniform)
        toolbox.register("select", tools.selTournament,tournsize=self.tournamentSel)
        #toolbox.register("elitism", tools.selBest, k=numSel)
        population = toolbox.population(n=self.populationSize)
        # The genetic algorithm, this implementation ia mu+lambda
        # it is feeded with a population of individuals, a mutation
        # and crossover probabilities and a number of generations
        offspring = algorithms.eaMuCommaLambda(population, toolbox,mu=self.muSel,lambda_=self.lambdaSel,cxpb=self.crossProb, mutpb=self.mutProb,ngen=self.numGen)
        # the top ten individuals are printed
        #topTen = tools.selBest(population, k=10)
        #print(topTen)
        best = tools.selBest(population, k=1)
        return best[0],offspring
